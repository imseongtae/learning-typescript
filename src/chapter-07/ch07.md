# Chapter.07 - Interface



#### β…Β ν•™μµ λ©ν‘

```md
- νƒ€μ… λ³„μΉ­ λ€μ‹  μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν• κ°μ²΄ νƒ€μ… μ„ μ–Έν•κΈ°
- μ„ νƒμ  μ†μ„±, μ½κΈ° μ „μ© μ†μ„±, ν•¨μ, λ©”μ„λ“ λ“± λ‹¤μ–‘ν• μΈν„°νμ΄μ¤ μ†μ„± νƒ€μ… μ†κ°
- κ°μ²΄μ ν¬κ΄„μ μΈ μ†μ„±μ„ λ‹΄κΈ° μ„ν• μΈλ±μ¤ μ‹κ·Έλ‹μ² μ‚¬μ©ν•κΈ°
- μ¤‘μ²©λ μΈν„°νμ΄μ¤μ™€ extends μƒμ† ν™•μ¥μΌλ΅ μΈν„°νμ΄μ¤ μ¬μ‚¬μ©ν•κΈ°
- λ™μΌν• μ΄λ¦„μΌλ΅ μΈν„°νμ΄μ¤ λ³‘ν•©ν•κΈ°
```



## 7.0 μΈν„°νμ΄μ¤
μΈν„°νμ΄μ¤λ” κ°μ²΄ ν•νƒλ¥Ό μ„¤λ…ν•λ” λ λ‹¤λ¥Έ λ°©λ²• β…
- λ” μ½κΈ° μ‰¬μ΄ μ¤λ¥ λ©”μ‹μ§€ π
- λ” λΉ λ¥Έ μ»΄νμΌλ¬ μ„±λ¥ ποΈ
- ν΄λμ¤μ™€μ λ” λ‚μ€ μƒνΈ μ΄μ©μ„± β™Έ



## 7.1 νƒ€μ… λ³„μΉ­ vs μΈν„°νμ΄μ¤
<!-- λ‘ κµ¬λ¬Έμ€ κ±°μ κ°™λ‹¤ -->
μƒκΈ΄ κ²ƒμ€ λ‘κ°™κµ¬λ§π

```ts
type Poet = {
  born: number;
  name: string;
};

interface Poet {
  born: number;
  name: string;
}
```


### μΈν„°νμ΄μ¤μ™€ ν‹°μ… λ³„μΉ­ μ‚¬μ΄ μ£Όμ” μ°¨μ΄μ 
- μ†μ„± μ¦κ°€λ¥Ό μ„ν•΄ λ³‘ν•© ν•  μ μμ
- ν΄λμ¤κ°€ μ„ μ–Έλ κµ¬μ΅°μ νƒ€μ…μ„ ν™•μΈν•λ”λ° μ‚¬μ©ν•  μ μμ§€λ§ νƒ€μ… λ³„μΉ­μ€ μ‚¬μ©ν•  μ μ—†μ
- μΌλ°μ μΌλ΅ μΈν„°νμ΄μ¤μ—μ„ νƒ€μ…μ¤ν¬λ¦½νΈ κ²€μ‚¬κΈ°κ°€ λ” λΉ¨λ¦¬ λ™μ‘ν•λ‹¤.
  - λ‚΄λ¶€μ μΌλ΅ λ” μ‰½κ² μΊμ‹ν•  μ μλ” λ…λ…λ νƒ€μ…μ„ μ„ μ–Έ
- μΈν„°νμ΄μ¤λ” μ΄λ¦„ μ—†λ” κ°μ²΄ λ¦¬ν„°λ΄μ λ³„μΉ­μ΄ μ•„λ‹ μ΄λ¦„ μλ” κ°μ²΄λ΅ κ°„μ£Όλλ―€λ΅ μ–΄λ ¤μ΄ νΉμ΄μΌ€μ΄μ¤μ—μ„ λ‚νƒ€λ‚λ” μ¤λ¥ λ©”μ‹μ§€λ¥Ό μΆ€ λ” μ‰½κ² μ½μ„ μ μμ


### μμ 

```ts
let valueLater: Poet;

// Ok
valueLater = {
  born: 1935,
  name: 'Sara Teasdale',
};

valueLater = "Emily Dickinson";
// Error: Type 'string' is not assignable to 'Poet'.

valueLater = {
  born: true,
  // Error: Type 'boolean' is not assignable to type 'number'.
  name: 'Sappho'
};
```


### κ·Όλ° μ •λ§ λ” λΉ λ¥Έκ°€μ”? π¤”


```ts
// interfaceMassExample.ts

interface IBase {
  id: number;
}

interface IUser extends IBase {
  name: string;
  age: number;
}

// 100κ°μ μΈν„°νμ΄μ¤ μƒμ„±
interface IExtraInfo1 extends IBase { detail: string; }
// ...
interface IExtraInfo100 extends IBase { detail: string; }

const users: IUser[] = [];

// 100κ°μ λ°μ΄ν„° μƒμ„±
for (let i = 0; i < 100; i++) {
  users.push({
    id: i,
    name: `User${i}`,
    age: i
  });
}

function greetUser(user: IUser) {
  return `Hello, ${user.name}!`;
}

users.forEach(u => console.log(greetUser(u)));
```


```ts
// typeMassExample.ts

type TBase = {
  id: number;
}

type TUser = TBase & {
  name: string;
  age: number;
}

// 100κ°μ νƒ€μ… μƒμ„±
type TExtraInfo1 = TBase & { detail: string; }
// ...
type TExtraInfo100 = TBase & { detail: string; }

const users: TUser[] = [];

// 100κ°μ λ°μ΄ν„° μƒμ„±
for (let i = 0; i < 100; i++) {
  users.push({
    id: i,
    name: `User${i}`,
    age: i
  });
}

function greetUser(user: TUser) {
  return `Hello, ${user.name}!`;
}

users.forEach(u => console.log(greetUser(u)));
```

```bash
$ time tsc interfaceMassExample.ts
$ time tsc typeMassExample.ts
```

νμ‚¬μ— μ½”λ“λ¥Ό λ‘κ³  μ™”μ–΄μ”... π¥²



## 7.2 μΈν„°νμ΄μ¤ μ†μ„± νƒ€μ…
μλ°”μ¤ν¬λ¦½νΈ κ°μ²΄λ” μ‚¬μ©ν•  λ• λ‚―μ„¤κ³ , μ΄μƒν•  μ μλ‹¤ π‡
<!-- 
  νƒ€μ…μ¤ν¬λ¦½νΈλ” μ΄λ¬ν• μ§€μ μ„ λ•κΈ° μ„ν•΄ μΈν„°νμ΄μ¤κ°€ μ΄μƒν• λ¶€λ¶„μ„ λ¨λΈλ§ν•  μ μλ„λ΅
 μ μ©ν• νƒ€μ… μ‹μ¤ν… λ„κµ¬λ¥Ό μ κ³µν•λ‹¤. 
-->
- μ„ νƒμ  μ†μ„±
- μ½κΈ° μ „μ© μ†μ„±
- ν•¨μμ™€ λ©”μ„λ“ 
- νΈμ¶ μ‹κ·Έλ‹μ²
- μΈλ±μ¤ μ‹κ·Έλ‹μ²


### 7.2.1 μ„ νƒμ  μ†μ„± μμ 

<!-- λ‘ κµ¬λ¬Έμ€ κ±°μ κ°™λ‹¤ -->

```ts
interface Book {
  author?: string;
  pages: number;
};

// Ok
const ok: Book = {
    author: "Rita Dove",
    pages: 80,
};

const missing: Book = {
    author: "Rita Dove"
};
// Error: Property 'pages' is missing in type
// '{ author: string; }' but required in type 'Book'.
```


### 7.2.3 ν•¨μμ™€ λ©”μ„λ“ 
μΈν„°νμ΄μ¤ λ©¤λ²„λ¥Ό ν•¨μλ΅ μ„ μ–Έν•λ” λ‘ κ°€μ§€ λ°©λ²•
<!-- 
  νƒ€μ…μ¤ν¬λ¦½νΈλ” μΈν„°νμ΄μ¤ λ©¤λ²„λ¥Ό ν•¨μλ΅ μ„ μ–Έν•λ” λ‘ κ°€μ§€ λ°©λ²•μ„ μ κ³µ,
  JSμ—μ„ κ°μ²΄λ¥Ό ν•¨μλ΅ μ„ μ–Έν•λ” λ°©λ²•κ³Ό λ™μΌ
-->

```ts
interface HasBothFunctionTypes {
  property: () => string;
  method(): string;
}

const hasBoth: HasBothFunctionTypes = {
  property: () => "",
  method() {
    return "";
  }
};

hasBoth.property(); // Ok
hasBoth.method(); // Ok
```


### 7.2.3 νΈμ¶ μ‹κ·Έλ‹μ²
<!--  -->
κ°’μ„ ν•¨μμ²λΌ νΈμ¶ν•λ” λ°©μ‹μ— λ€ν• νƒ€μ… μ‹μ¤ν…μ μ„¤λ…

```ts
type FunctionAlias = (input: string) => number;

interface CallSignature {
  (input: string): number;
}

// Type: (input: string) => number
const typedFunctionAlias: FunctionAlias = (input) => input.length; // Ok

// Type: (input: string) => number
const typedCallSignature: CallSignature = (input) => input.length; // Ok
```



## 7.3 μΈν„°νμ΄μ¤ ν™•μ¥
ν•νƒκ°€ λΉ„μ·ν• μ—¬λ¬ κ°μ μΈν„°νμ΄μ¤λ¥Ό κ°–κ² λ  λ• π³
<!-- 
  TSλ” μΈν„°νμ΄μ¤κ°€ λ‹¤λ¥Έ μΈν„°νμ΄μ¤μ λ¨λ“  λ©¤λ²„λ¥Ό λ³µμ‚¬ν•΄μ„ 
  μ„ μ–Έν•  μ μλ” ν™•μ¥λ μΈν„°νμ΄μ¤λ¥Ό ν—μ©
 -->
- μ†μ„± μ¬μ •μ
- λ‹¤μ¤‘ μΈν„°νμ΄μ¤ ν™•μ¥ 
<!-- λ”±ν λ³Όκ² μ—†μ–΄μ„ λ„μ–΄κ°‘λ‹λ‹¤. -->


### extends ν‚¤μ›λ“

```ts
interface Writing {
    title: string;
}

interface Novella extends Writing {
    pages: number;
}

// Ok
let myNovella: Novella = {
    pages: 195,
    title: "Ethan Frome",
};
```



## 7.4 μΈν„°νμ΄μ¤ λ³‘ν•©
μΈν„°νμ΄μ¤μ μ¤‘μ”ν• νΉμ§• μ¤‘ ν•λ‚λ” μ„λ΅ λ³‘ν•©ν•λ” λ¥λ ¥
<!-- 
  λ‘ κ°μ μΈν„°νμ΄μ¤κ°€ λ™μΌν• μ΄λ¦„μΌλ΅ λ™μΌν• μ¤μ½”λ“μ— μ„ μ–Έλ κ²½μ°,
  μ„ μ–Έλ λ¨λ“  ν•„λ“λ¥Ό ν¬ν•¨ν•λ” λ” ν° μΈν„°νμ΄μ¤κ°€ μ½”λ“μ— μ¶”κ°€λ¨
 -->

```ts
interface Merged {
  fromFirst: string;
}

interface Merged {
  fromSecond: number;
}

// Equivalent to:
// interface Merged {
//   fromFirst: string;
//   fromSecond: number;
// }
```


## 7.4.1 μ΄λ¦„μ΄ μ¶©λλλ” λ©¤λ²„
<!-- λ³‘ν•©λ μΈν„°νμ΄μ¤λ” νƒ€μ΄μ΄ λ‹¤λ¥Έ λ™μΌν• μ΄λ¦„μ μ†μ„±μ„ μ—¬λ¬ λ² μ„ μ–Έν•  μ μ—†λ‹¤ -->
μ΄λ¦„μ΄ μ• κ²ΉμΉλ©΄ μΆ‹κ² λ„¤π¥²

```ts
interface MergedProperties {
  same: (input: boolean) => string;
  different: (input: string) => string;
}

interface MergedProperties {
  same: (input: boolean) => string; // Ok

  different: (input: number) => string;
  // Error: Subsequent property declarations must have the same type.
  // Property 'different' must be of type '(input: string) => string',
  // but here has type '(input: number) => string'.
}
```
<!-- 
λ©”λ¨
μ¤λ²„λΌμ΄λ”©μ€ μ„μ•„λ κ΄€κ³„μ—μ„λ§
μΈν„°νμ΄μ¤μ—μ„λ” μ“Έ μ μ—†λ‹¤.
 -->


## 7μ¥ λ π¥Ή
